#!/usr/bin/env bash

# FLSC-portfolio: build.sh
#
# built with this inspirational message in mind: Why tf would we use make
# edited from cav
#
# Licensed under the:
# BSD 3-Clause License
#
# Copyright (c) 2024, h4rl
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# Made with <3 by h4rl!

shopt -s nullglob # remove words if not found
# set -x            # show cmds
set -e # fail globally

__NAME__="flscio: build.sh"
__AUTHOR__="h4rl"
__DESCRIPTION__="Compiles and links the flscio into an executable"
__LICENSE__="BSD 3-Clause License"
__VERSION__="0.1.0"

BUILD="$(pwd)/backend/build"
OUT="${BUILD}/out"
BIN="${BUILD}/bin"

COLOR=true

CC="gcc"

if ${COLOR}; then
	ESCAPE=$(printf "\e")
	RED="${ESCAPE}[0;31m"
	GREEN="${ESCAPE}[0;32m"
	BLUE="${ESCAPE}[0;34m"
	CYAN="${ESCAPE}[0;36m"
	CLEAR="${ESCAPE}[0m"
fi

CFLAGS="-O3"
LINKER_FLAGS="-lmicrohttpd -lmagic -lz-ng -ljansson -lgcrypt -lgnutls"

if [[ ${3} == "--debug" ]]; then
	CFLAGS="-g ${CFLAGS}"
fi

# name projs by their directories
# and specify type :3

PROJ="backend"

SRC="$(pwd)/${PROJ}/src"
DIR="${SRC}/${PROJ}"

handle_failure() {
	local MESSAGE="${1}"

	if [[ -z ${MESSAGE} ]]; then
		echo "No message provided, are you using this right?"
		exit 1
	fi

	echo "${RED}!${CLEAR} ${MESSAGE}${CLEAR}"
	exit 1
}

print_help() {
	cat <<EOF
${RED}${__NAME__}${CLEAR} v${GREEN}${__VERSION__}${CLEAR}
Licensed under: ${CYAN}${__LICENSE__}${CLEAR}

USAGE: ${GREEN}${0}${CLEAR} ${RED}{FLAGS} ${BLUE}{EXECUTABLE_NAME}${CLEAR}
${RED}-c${CLEAR} | ${RED}--compile${CLEAR}
Compiles ${CYAN}libcav${CLEAR} and ${CYAN}cav${CLEAR} into an executable${CLEAR}.

${RED}-l${CLEAR} | ${RED}--link${CLEAR}
Links all the files in ${CYAN}${OUT}/${CLEAR} to an executable with ${BLUE}{EXECUTABLE_NAME}${CLEAR}

${RED}-cd${CLEAR} | ${RED}--compilation-database${CLEAR}
Generates a compilation database for the project using bear

${RED}-d${CLEAR} | ${RED}--delete${CLEAR} | ${RED}--clean${CLEAR}
Cleans all files in ${CYAN}${BIN}/${CLEAR} & ${CYAN}${OUT}/${CLEAR}

${RED}-vg${CLEAR} | ${RED}--delete-cores${CLEAR} | ${RED}--delete-vgcores${CLEAR} | ${RED}--clean-vgcores${CLEAR} | ${RED}--clean-cores${CLEAR}
Cleans all vgcore files generated by valgrind in the repo.

Made with ${RED}<3${CLEAR} by ${__AUTHOR__}
EOF
}

# iterates and compiles each file on selected target, then compiles main.c, moving them to out

compile() {
	local -a C_FILES

	local -a TRIMMED_C_FILENAMES

	local TRIMMED_C_FILE
	local TRIMMED_C_FILENAME

	if [[ ! -d ${OUT} ]]; then
		mkdir "${OUT}"
	fi

	mapfile -t C_FILES < <(find "${DIR}" -type f -name "*.c")

	for ((i = 0; i < ${#C_FILES[@]}; i++)); do
		TRIMMED_C_FILE="${C_FILES[${i}]%.*}"
		TRIMMED_C_FILENAME="${TRIMMED_C_FILE##*/}"
		TRIMMED_C_FILENAMES+=("${TRIMMED_C_FILENAME}")
		echo -e "${BLUE}>${CLEAR} Compiling: ${CYAN}${TRIMMED_C_FILENAMES[${i}]}.c${CLEAR}.."
		${CC} "${CFLAGS}" -c "${C_FILES[${i}]}" -o "${OUT}/${TRIMMED_C_FILENAME}.o"
	done

	#	if [[ ${TYPE} != "lib" ]]; then
	echo -e "${BLUE}>${CLEAR} Compiling: main.c.."
	${CC} "${CFLAGS}" -c "${SRC}/main.c" -o "${OUT}/main.o"

	echo -e "${GREEN}✓${CLEAR} Compiled ${CYAN}${TRIMMED_C_FILENAMES[*]}${CLEAR} & ${CYAN}main${CLEAR} successfully"

	unset C_FILES
	unset TRIMMED_C_FILE
	unset TRIMMED_C_FILENAME
	unset TRIMMED_C_FILENAMES
}

generate_compilation_database() {
	bear -- "${0}" -c
}

# links all object files in out/ to an executable bin or a library in lib

link() {
	local -a OBJECTS
	local NAME
	local -a TRIMMED_FILES

	if [[ ! -d ${BIN} ]]; then
		mkdir "${BIN}"
	fi

	mapfile -t OBJECTS < <(find "${OUT}" -type f -name "*.o")

	TRIMMED_FILES="${OBJECTS[*]##*/}"
	pushd "${OUT}" >/dev/null || handle_failure "Failed to pushd" #|| echo "Failed to pushd" && exit 1

	if [[ -n ${1} ]]; then
		NAME="${1}"
	else
		NAME="${PROJ}"
	fi

	echo -e "${BLUE}>${CLEAR} Linking: ${CYAN}${TRIMMED_FILES[*]}${CLEAR}.."
	${CC} ${LINKER_FLAGS} -o "${BIN}/${NAME}" ${TRIMMED_FILES[*]}
	echo -e "${GREEN}✓${CLEAR} Linked ${CYAN}${TRIMMED_FILES}${CLEAR} to ${BLUE}${NAME}${CLEAR} successfully"

	popd >/dev/null || handle_failure "Failed to popd" # || echo "Failed to popd" && exit 1
}

# removes dangling object files that shouldn't be there, used to be required, not that much as of lately though.

clean_dangling() {
	local DIR1 # C-DIR 1
	local DIR2 # C-DIR 2 / OUT-DIR
	local DIR3 # OUT-DIR

	local OUTPUTDIR

	local LINE

	DIR1=${1}
	DIR2=${2}
	DIR3=${3}

	# Extract .c and .o filenames without paths and store them in temporary files

	if [[ -z ${DIR3} ]]; then
		find "$DIR1" -name "*.c" -exec basename {} \; >"c_files.txt"
		find "$DIR2" -name "*.o" -exec basename {} \; >>"o_files.txt"
		OUTPUTDIR="${DIR2}"
	else
		find "$DIR1" -name "*.c" -exec basename {} \; >"c_files.txt"
		find "$DIR2" -name "*.c" -exec basename {} \; >>"c_files.txt"
		find "$DIR3" -name "*.o" -exec basename {} \; >"o_files.txt"
		OUTPUTDIR="${DIR3}"
	fi

	echo "main.c" >>"c_files.txt"

	# Compare the lists and find .o files in dir2 that do not have a corresponding .c file in dir1
	grep -Fxv -f <(sed 's/\.c$/.o/' "c_files.txt") "o_files.txt" >"extra_o_files.txt" || true

	# Remove extra .o files from dir2
	while read -r LINE; do
		rm -f "${OUTPUTDIR}/${LINE}"
	done <"extra_o_files.txt"

	# Cleanup
	rm c_files.txt o_files.txt extra_o_files.txt
}

# cleans both /out && /bin

clean() {
	local CLEAN
	local LOCALOUT
	local LOCALBIN
	local LOG

	LOCALOUT=${1}
	LOCALBIN=${2}
	CONFIRMATION=${3}
	LOG=${4:true}

	if ${LOG}; then
		echo -e "${RED}!${CLEAR} Cleaning ${CYAN}${LOCALOUT}${CLEAR} & ${CYAN}${LOCALBIN}${CLEAR}."
	fi
	if ! [[ ${CONFIRMATION} =~ [yY] ]]; then
		echo -ne "${RED}!${CLEAR} You sure you want to proceed? [${GREEN}y${CLEAR}/${RED}N${CLEAR}]: "
		read -r CLEAN
	else
		CLEAN="y"
	fi
	if [[ ${CLEAN} =~ [Yy] ]]; then
		rm -fr "${LOCALOUT:?}/*"
		rm -fr "${LOCALBIN:?}/*"
		if ${LOG}; then
			echo -e "${GREEN}✓${CLEAR} Cleaned ${CYAN}${LOCALOUT}${CLEAR} & ${CYAN}${LOCALBIN}${CLEAR} successfully."
		fi
	else
		echo -e "${GREEN}✓${CLEAR} Cancelled."
	fi
}

clear_vgcores() {
	local -a FILES
	local FILE

	FILES=$(find "${PWD}" -type f -name "vgcore.*")

	if [[ -z ${FILES} ]]; then
		echo -e "${RED}!${CLEAR} No files found :("
		return
	fi

	for FILE in ${FILES}; do
		if [[ -f ${FILE} ]]; then
			rm "${FILE}"
			echo -e "${GREEN}✓${CLEAR} Deleted file ${CYAN}\"${FILE}\"${CLEAR}"
		else
			echo -e "${RED}!${CLEAR} File does not exist :("
		fi
	done
}

case $1 in
"-c" | "--compile")
	compile
	;;
"-l" | "--link")
	link "${2}"
	;;
"-d" | "--delete" | "--clean")
	clean "${OUT}" "${BIN}" "n"
	;;
"-vg" | "--delete-cores" | "--delete-vgcores" | "--clean-vgcores" | "--clean-cores")
	clear_vgcores
	;;
"-cd" | "--compilation-database")
	generate_compilation_database
	;;
"--help" | "-h" | "-?" | *)
	print_help "${@}"
	;;
esac
